            MemoryCopy => {
                // Pop: size, src, dest (in reverse order from stack)
                let size = match self.stack.pop().unwrap() {
                    Value::I32(n) => n as usize,
                    _ => unreachable!(),
                };
                let src = match self.stack.pop().unwrap() {
                    Value::I32(n) => n as usize,
                    _ => unreachable!(),
                };
                let dest = match self.stack.pop().unwrap() {
                    Value::I32(n) => n as usize,
                    _ => unreachable!(),
                };
                
                // Get memory
                let mem = &mut self.mems[self.frame.module().mem_addrs[0]];
                
                // Check bounds
                if src + size > mem.data.len() || dest + size > mem.data.len() {
                    return Err(Trap {
                        origin: TrapOrigin::StoreOutOfMemory,
                    });
                }
                
                // Copy memory (handle overlapping regions)
                for i in 0..size {
                    let byte = mem.data[src + i];
                    mem.data[dest + i] = byte;
                }
                
                Ok(Continue)
            }

            MemoryFill => {
                // Pop: size, value, dest
                let size = match self.stack.pop().unwrap() {
                    Value::I32(n) => n as usize,
                    _ => unreachable!(),
                };
                let value = match self.stack.pop().unwrap() {
                    Value::I32(n) => (n & 0xFF) as u8,
                    _ => unreachable!(),
                };
                let dest = match self.stack.pop().unwrap() {
                    Value::I32(n) => n as usize,
                    _ => unreachable!(),
                };
                
                // Get memory
                let mem = &mut self.mems[self.frame.module().mem_addrs[0]];
                
                // Check bounds
                if dest + size > mem.data.len() {
                    return Err(Trap {
                        origin: TrapOrigin::StoreOutOfMemory,
                    });
                }
                
                // Fill memory
                for i in 0..size {
                    mem.data[dest + i] = value;
                }
                
                Ok(Continue)
            }
